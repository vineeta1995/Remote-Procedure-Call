/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "question.h"
#include <stdlib.h>
#include <stdio.h>
static int clnt_idx=0;
static int flag = 0;
static char *questions[50];
static char *answers[50];

struct clnt clntarr[100];
int client_pos(int addr)        // method to find position of client in the client array(clntarr)
{
	int size;
	size=sizeof(clntarr)/sizeof(clntarr[0]);
	int i=0;
	while(i<size)
	{
		if(addr==clntarr[i].address)
			return i;
		i++;
	}
	return -1;
}

int compare (const void * a, const void * b)           // method to define comparision used by qsort
{

  clnt *clntA = (clnt *)a;
  clnt *clntB = (clnt *)b;

  return ( clntB->score - clntA->score );
}

void sort()          // method to sort the array cltnarr
{
	int size=sizeof(clntarr)/sizeof(clntarr[0]);
	qsort(clntarr,size,sizeof(clnt),compare);
}

void generate_initial()        // method to read initial values(questions,answers and old client scores) into the respective arrays.
{
	int i=0;
	int j=0;
	if(flag == 0){	
	char ch;
	char qsn_file[100]="/home/HDUSER/Downloads/Agthu/Database-20180917/questions.txt";
	char ans_file[100]="/home/HDUSER/Downloads/Agthu/Database-20180917/answers.txt";
	FILE *qfp=fopen(qsn_file, "r");
	FILE *afp=fopen(ans_file, "r");
	if (qfp == NULL){
      		perror("Error while opening the file.\n");
      		exit(EXIT_FAILURE);
		}
	if (afp == NULL){
      		perror("Error while opening the file.\n");
      		exit(EXIT_FAILURE);
		}
	char qline[200];
	char aline[20];	
	int n;
	while (fgets(qline, sizeof(qline), qfp) != NULL) {
    		questions[i] = malloc(200);
    		strcpy(questions[i], qline);
    		i++;
		}

	while (fscanf(afp, "%s", aline) != EOF)  
	{
		answers[j]=malloc(strlen(aline));
		strcpy(answers[j],aline);
		j++;
	}
	char score_file[100]="score.csv";
	FILE *sfp=fopen(score_file, "r");
	if (sfp == NULL){
      		perror("Error while opening the file.\n");
      		exit(EXIT_FAILURE);
	}
	char buf[15];
	int counter=0;

	while(fgets(buf, sizeof(buf), sfp) != NULL){
		char *token = strtok(buf, ",");
		while( token != NULL ) 
	   	{
		if(counter >=3 && counter%2==0){	
			clntarr[clnt_idx].score=atoi(token);
			//printf( "%d  %d sdsa\n ",clntarr[clnt_idx].score,clnt_idx); 
			clnt_idx++;}
	      	else if(counter >=3 && counter%2==1){
			clntarr[clnt_idx].address=atoi(token); 
			//printf( "%d  %d sdsa\n ",clntarr[clnt_idx].address,clnt_idx);
			}
		counter++; 
		token = strtok(NULL,",");
	   	}			  
	}
	flag = 1;
	}

}

void update(int addr)     // method to update the client scores into the file.
{
	FILE *fp;
	char filename[] = "score.csv";
	fp=fopen(filename,"w+");
	fprintf(fp,"CLientID,Score");
	int size=sizeof(clntarr)/sizeof(clntarr[0]);
	for(int k=0;k<size;k++)
	{
		if(clntarr[k].address!=0){
		fprintf(fp,"\n");
		fprintf(fp,"%d,%d",clntarr[k].address,clntarr[k].score);
		}
	}
	fclose(fp);
}

qns_output *
qns_probe_1_svc(qns_input *argp, struct svc_req *rqstp)    // method called when client requests for question
{
	static qns_output result;
	generate_initial();
	int index = (rand() % (49 - 0 + 1)) + 0; // rand_number%(upper_limit - lower_limit +1) + lower_limit
	int clientaddr=rqstp->rq_xprt->xp_raddr.sin_addr.s_addr;
	int pos=client_pos(clientaddr);
	if(pos == -1){	
		clntarr[clnt_idx].address=clientaddr;
		pos = clnt_idx;
	}	
	clntarr[pos].index = index;
	printf("client address %u\n",clntarr[pos].address);
	strcpy(result.qsn,questions[index]);
	clnt_idx++;
	printf("%s",result.qsn);
	return &result;
}

qns_output *
qns_checkanswer_1_svc(qns_input *argp, struct svc_req *rqstp)   // method called when client answers the question
{
	static qns_output  result;
	int clientaddr=rqstp->rq_xprt->xp_raddr.sin_addr.s_addr;
	int pos=client_pos(clientaddr);
	if(clntarr[pos].index<50 && strcmp(argp->ans,answers[clntarr[pos].index])==0)
	{
		clntarr[pos].score++;
		//printf("%d %d",pos,clntarr[pos].score);
	}	
	strcpy(result.message,"Answer Received");
	return &result;
}

qns_output *
qns_getscore_1_svc(qns_input *argp, struct svc_req *rqstp)   // method called when client requests for score
{
	static qns_output  result;
	int clientaddr=rqstp->rq_xprt->xp_raddr.sin_addr.s_addr;
	int pos=client_pos(clientaddr);
	update(clientaddr);
	result.score=clntarr[pos].score;
	return &result;
}

qns_output *
qns_getrank_1_svc(qns_input *argp, struct svc_req *rqstp)       // method called when client requests for rank
{
	static qns_output  result;
	int clientaddr=rqstp->rq_xprt->xp_raddr.sin_addr.s_addr;
	sort();
	int pos=client_pos(clientaddr);
	clntarr[pos].rank = pos+1;
	result.rank= clntarr[pos].rank;
	return &result;
}

qns_output *
qns_exit_1_svc(qns_input *argp, struct svc_req *rqstp)     // method called when client requests to exit
{
	static qns_output  result;
	int clientaddr=rqstp->rq_xprt->xp_raddr.sin_addr.s_addr;
	int pos=client_pos(clientaddr);
	int size=sizeof(clntarr)/sizeof(clntarr[0]);
	while(pos<size-1)
	{
		clntarr[pos]=clntarr[pos+1];
		pos++;
	}

	strcpy(result.message,"Thank You");
	return &result;
}


